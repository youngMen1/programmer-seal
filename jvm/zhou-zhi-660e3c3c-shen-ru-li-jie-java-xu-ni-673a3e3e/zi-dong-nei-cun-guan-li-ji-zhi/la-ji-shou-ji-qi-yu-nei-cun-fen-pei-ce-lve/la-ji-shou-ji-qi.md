# 1.基本介绍

## 新生代收集器

#### 1.Serial收集器

#### 2.ParNew收集器

#### 3.Parallel Scavenge收集器

## 老年代收集器

#### 4.Serial Old收集器

#### 5.Parallel Old收集器

#### 6.CMS收集器

## 全区域的垃圾回收器

#### 7.G1收集器

## 1.1.Serial收集器

这个收集器是一个单线程的收集器，在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它线程结束。

### 1.1.1.特点

主要针对新生代；

采用复制算法；

单线程收集；

进行垃圾收集时，必须暂停所有工作线程，直到完成；

即会"Stop The World"；

Serial/Serial Old组合收集器运行示意图如下：

![](/static/image/20180611160921828.png)

### 1.1.2.应用场景

依然是HotSpot在Client模式下默认的新生代收集器；

也有优于其他收集器的地方：

简单高效（与其他收集器的单线程相比）；

对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；

在**用户的桌面应用场景中**，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的

**1、设置参数**

"-XX:+UseSerialGC"：添加该参数来显式的使用串行垃圾收集器；

**2、Stop TheWorld说明**

JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即GC停顿；

会带给用户不良的体验；

从JDK1.3到现在，从Serial收集器-》Parallel收集器-》CMS-》G1，用户线程停顿时间不断缩短，但仍然无法完全消除；

## 1.2.ParNew收集器

ParNew垃圾收集器是Serial收集器的多线程版本。

### 1.2.1.特点

除了多线程外，其余的行为、特点和Serial收集器一样；  
如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；  
两个收集器共用了不少代码；  
ParNew/Serial Old组合收集器运行示意图如下：  
![](/static/image/2018061116094429.png)  
**1.应用场景**  
在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作；  
但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。  
**2.设置参数**  
"-XX:+UseConcMarkSweepGC"：指定使用CMS后，会默认使用ParNew作为新生代收集器；  
"-XX:+UseParNewGC"：强制指定使用ParNew；  
"-XX:ParallelGCThreads"：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；  
**3.为什么只有ParNew能与CMS收集器配合**  
CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；  
CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；  
因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；

## 1.3.Parallel Scavenge收集器

Parallel Scavenge收集器是一个**新生代收集器**，使用**复制算法**的**并行收集器**Parallel Scavenge 收集器使用两个参数控制吞吐量

```
MaxGCPauseMillis:控制最大的垃圾收集停顿时间
GCRatio：直接设置吞吐量的大小
```

直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，

但是GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。

比如原来10秒收集一次，每次停顿100毫秒。但是线程编程每5秒收集一次，每次停顿70毫秒，停顿时间下降的同时，吞吐量也下降了。

### 1.3.1.Parallel Scavenge的自适应调节策略

Parallel Scavenge收集器有一个参数- XX：+UseAdaptiveSizePolicy当这个参数打开之后，就不需要手动指定新生代的大小，Eden和Survivor区的比例，晋升老年代对象等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量，这种调节方式成为GC自适应的调节策略。  
![](/static/image/20190323103421906.png)

### 1.3.2.Parallel Scavenge和ParNew的对比分析

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

Parallel Scavenge收集器与ParNew收集器的一个重要区别是它具有自适应调节策略。

## 1.4.Serial Old收集器

Serial Old是Serial收集器的老年代版本，同样是**单线程收集器**，使用**标记-整理**算法。

![](/static/image/20190323111147624.png)

### 应用场景

## 1.5.Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，使用**多线程**和**标记-整理**算法。

### 应用场景

在注意吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加 Parallel Old收集器

这个收集器是在JDK1.6中才开始提供的，在此之前Parallel Scavenge一直处于尴尬的状态。原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old别无选择，由于老年代Serial Old性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量的最大化效果，直到Parallel Old收集器出现后，"吞吐量优先"收集器终于有了名副其实的应用组合

JDK1.6之前 Parallel Scavenge + Serial Old

JDK1.6以及之后 Parallel Scavenge + Parallel Old

![](/static/image/20190323111322489.png)

### 

## 1.6.CMS收集器

### 1.6.1.特性

由于垃圾回收时，都需要暂停用户线程，CMS\(Concurrent Mark Sweep\)收集器是一种以 获取最短停顿时间 为目标的收集器，重视服务的响应速度，希望系统停顿时间最短，能给用户带来良好的体验。

CMS收集器是基于"标记-清除"算法实现的，它的运作过程比较复杂，整个过程分为四个步骤:

初始标记 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要Stop The World\(暂停所有的用户线程\)

并发标记 并发标记阶段就是进行GC Roots Tracing的过程 \(用户不暂停\)—用户不暂停就还可能产生一些对象与GC Roots不可达

重新标记重新标记阶段是为了修正 并发标记期间 因用户程序继续运作而导致标记产生变动 的那一部分对象的标记记录，这个阶段的停顿时间会比初始阶段稍长一些,但是远比并发标记的时间短，仍然需要"Stop The World"

并发清除并发清除阶段会清除对象**（用户不暂停）**

整个过程中耗时最长的并发表及和并发清除过程收集线程可以与用户线程一起工作，所以整体上来说，CMS收集器的内存回收过程与用户线程一起并发执行。

### 1.6.2.优点

CMS是一款优秀的收集器，主要优点:**并发、低停顿**

### 1.6.3.缺点

CMS收集器对CPU的资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源，而导致应用程序变慢，总吞吐量会降低。

CMS无法处理浮动垃圾，由于CMS 并发清理阶段用户线程还在运行着，用户线程在运行自然就还会有新的垃圾产生，CMS无法在当次收集中处理掉它们，只好留到下一次GC再清理掉，这一部分垃圾叫做"浮动垃圾"。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS不能等到老年代几乎满了才开始收集，需要预留一部分空间提供给并发时的程序运作使用。要是CMS在运行期间预留的内存无法满足程序需要，就会出现一次"Concurrent Mode Failure"，这时虚拟机将启动后备方案:临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样下来停顿时间就长了

CMS收集器会产生大量的空间碎片，CMS是一款基于"标记-清除" 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，就会给大对象的分配带来很多麻烦，往往会出现还有很大的空间剩余，但是无法找到足够大连续的空间来分配当前对象，不得不提前触发一次Full GC

![](/static/image/20190323132658126.png)

### 1.6.4. Parallel Scavenge收集器 VS CMS收集器

CMS关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，由于与吞吐量密切相关，Parallel Scavenge收集器也经常称为"吞吐量优先"收集器

## 1.7.G1收集器

G1垃圾回收器是用在heap memory很大的情况下，把heap划分为很多很多的region块，然后并行的对其进行垃圾回收。

G1垃圾回收器在清除实例所占用的内存后，还会做内存压缩。

G1垃圾回收器回收region的时候基本不会Stop The World，从整体来看是基于标记-整理算法，从局部（两个region之间）来看基于复制算法。

![](/static/image/20190323141749762.png)

一个region有可能属于Eden、Survivor或者Tenured内存，图中的E表示Eden区，S表示Survivor区、T表示Tenured区、空白就是未使用的空间。G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。这种内存区域主要用于存储大对象-即大小超出一个region大小的50%的对象

### 1.7.1 年轻代垃圾收集

在G1垃圾收集器中，年轻代的垃圾回收过程使用复制算法  
，把Eden区和Survivor区的对象复制到新的Survivor区域  
![](/static/image/2019032314203110.png)

### 1.7.2 老年代垃圾收集

对于老年代的垃圾收集，G1（Garbage First）也分为四个阶段，基本与CMS垃圾收集器一样，但是略有不同

**初始标记（Initial Mark）** 同CMS垃圾收集器初始标记阶段一样，G1也需要暂停应用程序的执行，它会标记从跟对象出发，在根对象的第一层孩子结点中标记所有可达对象。但是G1的垃圾收集器的初始标记结点是跟Minor gc一起发生的。也就是说，**在G1中，不用像CMS那样，单独暂停应用程序的执行来运行初始标记阶段，而是在G1出发Minor gc的时候一并将老年代上的初始标记给做了。**  
**并发标记（Concurrent Mark）** **同CMS垃圾收集器并发标记阶段一样**，但G1还多做了一件事件，就是如果在并发标记阶段，发现哪些Tenured region中对象的存活率很小或者基本没有对象存活，那么G1就会在这个阶段将其回收掉，而不用等到后面的清除阶段，这也是Garbage First名字的由来，同时在该阶段，G1会计算每个region的存活率，方便后面的清除阶段使用。  
**最终标记（CMS中的remark阶段） 同CMS垃圾收集器重新标记阶段一样**，但是采用的算法不一样，G1采用了一种叫做STAB\(snapshot-at-the-begining\)的算法能够在Remark阶段更快的标记可达对象。  
**筛选回收（clean up/Copy） **在G1中，没有CMS对于的Sweep阶段。相反，它有一个Clean up/Copy阶段，在这个阶段中，G1会挑选出那么对象存活率低的region进行回收，这个阶段也是和minor gc一同完成的。  
![](/static/image/20190323150903133.png)  
G1是一款面向服务端应用的垃圾收集器，Hotspot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器  
你想追求低停顿、想让用户有更好的体验用G1  
如果你的应用追求吞吐量，G1并不能带来很明显的好处。

