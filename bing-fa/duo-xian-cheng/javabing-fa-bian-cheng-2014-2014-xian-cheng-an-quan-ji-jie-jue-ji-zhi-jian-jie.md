## [Java并发编程——线程安全及解决机制简介](https://www.cnblogs.com/zhanht/p/5450325.html)

**简介：**

本文主要介绍了Java多线程环境下，可能会出现的问题\(线程不安全\)以及相应的解决措施。通过本文，你将学习到如下几块知识：

1. 为什么需要多线程\(多线程的优势\)

2. 多线程带来的问题—线程安全

3. 产生线程不安全的原因

4. 有哪些方法能解决线程不安全

---

系好安全带，下面进入正文：

**一：为什么需要多线程？**

线程是Java语言中不可或缺的重要部分，它们能使复杂的异步代码变得简单，简化复杂系统的开发；能充分发挥多处理器系统的强大计算能力。多线程和多进程的区别与选择可以参考我的另一篇博客。

**\(1\) 优点**

1. 充分利用硬件资源。由于线程是cpu的基本调度单位，所以如果是单线程，那么最多只能同时在一个处理器上运行，意味着其他的CPU资源都将被浪费。而多线程可以同时在多个处理器上运行，只要各个线程间的通信设计正确，那么多线程将能充分利用处理器的资源。

2. 结构优雅。多线程程序能将代码量巨大，复杂的程序分成一个个简单的功能模块，每块实现复杂程序的一部分单一功能，这将会使得程序的建模，测试更加方便，结构更加清晰，更加优雅。

3. 简化异步处理。为了避免阻塞，单线程应用程序必须使用非阻塞I/O,这样的I/O复杂性远远高于同步I/O，并且容易出错。

**\(2\) 缺点**

1. 线程安全：由于统一进程下的多个线程是共享同样的地址空间和数据的，又由于线程执行顺序的不可预知性，一个线程可能会修改其他线程正在使用的变量，这一方面是给数据共享带来了便利；另一方面，如果处理不当，会产生脏读，幻读等问题，好在Java提供了一系列的同步机制来帮助解决这一问题，例如内置锁。

2. 活跃性问题。可能会发生长时间的等待锁，甚至是死锁。

3. 性能问题。 线程的频繁调度切换会浪费资源，同步机制会导致内存缓冲区的数据无效，以及增加同步流量。

**二：线程安全**

\(1\) 定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，则称这个类时线程安全的。线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

\(2\) 线程安全产生的原因：正确性取决于多个线程的交替执行时序，产生了竞态条件。

\(3\) 原子类： 应尽量使用原子类，这样会让你分析线程安全时更加方便，但需要注意的是用线程安全类构建的类并不能保证线程安全。例如，一个AtomicInteger get\(\) 和 AtomicInteger set\(\) 是线程安全的，在一个类的一个方法 f\(\)中同时用到了这两个方法，此时的f\(\)就是线程不安全的，因为你不能保证这个复合操作中的get 和 set同时更新。

**三：解决机制**

**1. 加锁**

\(1\) 锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。

\(2\) 加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。

\(3\) 加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。

**2. 不共享状态**

\(1\) 无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。

\(2\) 线程关闭： 仅在单线程环境下使用。

**3. 不可变对象**

可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量\(除String外\)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。

