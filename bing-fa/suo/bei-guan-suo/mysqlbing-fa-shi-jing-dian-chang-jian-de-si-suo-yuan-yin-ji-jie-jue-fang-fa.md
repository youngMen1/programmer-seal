# [Mysql并发时经典常见的死锁原因及解决方法](https://www.cnblogs.com/zejin2008/p/5262751.html)

**1.   mysql都有什么锁**

MySQL有三种锁的级别：页级、表级、行级。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

算法：

next KeyLocks锁，同时锁住记录\(数据\)，并且锁住记录前面的Gap

Gap锁，不锁记录，仅仅记录前面的Gap

Recordlock锁（锁数据，不锁Gap）

所以其实 Next-KeyLocks=Gap锁+ Recordlock锁

**.   什么情况下会造成死锁**



所谓死锁&lt;DeadLock&gt;: 是指两个或两个以上的进程在执行过程中,  
因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.  
此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.  
表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.

