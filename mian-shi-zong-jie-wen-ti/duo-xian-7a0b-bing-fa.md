## 1、如何创建线程？如何保证线程安全？ {#1、如何创建线程？如何保证线程安全？}

继承Thread类，实现Runnable接口，使用Executor框架来创建线程池。

使用volatile、synchronized关键字或者Jdk的各种并发API可以保证线程安全

## 2、什么是死锁？如何避免 {#2、什么是死锁？如何避免}

死锁是两个或两个以上的线程都在等待对方执行完毕才能往下执行下去，结果就是所有的线程都陷入的无限的等待当中；

死锁的发生有着四个必要条件，分别是互斥性，请求和保持，不可剥夺和循环等待条件，只要破坏了任意条件死锁就不会发生，最简单的方法就是线程以同样的顺序加锁和释放锁，也就是破坏了第四个条件。

## 3、Volatile关键字的作用？ {#3、Volatile关键字的作用？}

保证变量的可见性，即读取的变量值一定是最新的，并不能保证线程安全

## 4、HashMap在多线程环境下使用需要注意什么？为什么？ {#4、HashMap在多线程环境下使用需要注意什么？为什么？}

要注意死循环的问题，HashMap的put操作可以造成重新分配存储大小resize的动作，这个动作在多线程并发下会发生线程死循环的问题。

## 5、Java程序中启动一个线程是用run\(\)还是start\(\)? {#5、Java程序中启动一个线程是用run-还是start-？}

start\(\)

## 6、什么是守护线程？有什么用？ {#6、什么是守护线程？有什么用？}

守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种，

1、守护线程，比如垃圾回收线程，就是最典型的守护线程。

2、用户线程，就是应用程序里的自定义线程。

## 7、线程和进程的差别是什么？ {#7、线程和进程的差别是什么？}

进程是执行着的应用程序，线程是进程的一个执行序列，一个进程可以有多个线程。

## 8、Java里面的Threadlocal是怎样实现的？ {#8、Java里面的Threadlocal是怎样实现的？}

ThreadLocal：线程局部变量。为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。

每个运行的线程都会有一个类型为ThreadLocal.ThreadLocalMap的map,这个map就是用来存储与这个线程绑定的变量。

## 9、ConcurrentHashMap的实现原理是？ {#9、ConcurrentHashMap的实现原理是？}

在jdk1.6中ConcurrentHashMap使用锁分段技术提高并发访问效率。首先将数据分成一段一段地存储，然后给每一段数据配一个锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。然而在jdk1.8中的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。

附：[深入浅出CAS](https://www.jianshu.com/p/fb6e91b013cc)

