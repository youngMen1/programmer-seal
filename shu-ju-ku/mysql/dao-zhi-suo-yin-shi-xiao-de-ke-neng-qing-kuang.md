# 1.导致索引失效的可能情况

1.使用多列作为索引，则需要遵循最左前缀匹配原则（查询从索引的最左前列开始并且不跳过索引中的列）

2.不再索引列上做任何操作，例如（计算，函数，（自动 or 手动的类型转换）），会导致索引失效而转向全表扫描

3.尽量使用覆盖索引（之访问索引列的查询），减少select \*,覆盖索引能减少回表次数；

4.mysql再使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描

5.like以通配符开头（%abc） mysql索引会失效变成全表扫描的操作；

6.字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）

7.少用or，用它来连接时会索引失效；

8.复合索引不能使用不等于（!=  &lt;&gt;）或is null \(is not null\)，否则自身以及右侧所有全部失效。  
  复合索引中如果有&gt;，则自身和右侧索引全部失效。

# 2.注意事项

### 2.1.范围查询

mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引

### 2.2.like 语句的索引问题

如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀  
在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描

### 2.3.不要在列上进行运算

如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描  
例如 select \* from user where YEAR\(birthday\) &lt; 1990  
可以改造成 select \* from users where birthday &lt;’1990-01-01′

### 2.4.索引不会包含有 NULL 值的列

只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为 NULL

### 2.5.尽量选择区分度高的列作为索引

尽量选择区分度高的列作为索引，区分度的公式是 count\(distinct col\)/count\(\*\)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。一般需要 join 的字段都要求区分度 0.1 以上，即平均 1 条扫描 10 条记录

### 2.6.覆盖索引的好处

如果一个索引包含所有需要的查询的字段的值，我们称之为覆盖索引。覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量

### 

# 3.参考

导致索引失效的可能情况：

[https://blog.csdn.net/monkey\_d\_feilong/article/details/52291556](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)

